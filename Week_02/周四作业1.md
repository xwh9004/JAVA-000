学习笔记

GC日志分析

**1 SerialGC** 

日志文件， [SerialGC_512m.demo.log](SerialGC_512m.demo.log)， [SerialGC_1g.demo.log](SerialGC_1g.demo.log) ，[SerialGC_2g.demo.log](SerialGC_2g.demo.log) 

SerialGC_512m.demo.log中第一次发生GC日志如下：

2020-10-24T17:36:03.460+0800: 0.327: [GC (Allocation Failure) 2020-10-24T17:36:03.461+0800: 0.327: [DefNew: 34847K->4351K(39296K), 0.0082927 secs] 34847K->12927K(126720K), 0.0084992 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] 

- Allocation Failure：触发GC原因

- 2020-10-24T17:36:03.461+0800: 0.327：触发GC时刻，JVM启动后0.328s发生一次GC

- DefNew：GC垃圾收集器名称，DefNew表示 年轻代使用的单线程、标记­复制、STW 垃圾收集器 

- 34847K->4351K(39296K)： 34847K 表示GC前新生代使用大小，4351K表示 GC后新生代使用，括号中39296K新生   代总大小，可计算出GC回收了 30496K=34847K-4351K,可以看到GC前新生代使用率 88.6%=34847K/39296K，GC后新生代使用率 11%=4351K/39296K。0.0082927 secs 表示 GC执行的时间

  回收速率 30496K/8ms=3.7M/ms

-   34847K->12927K(126720K), 0.0084992 secs：34847K，表示GC前Java堆总的使用大小，12927K，表示GC后Java堆总的使用大小，126720K,表示Java堆的总大小，可以看到首次GC前，tenured老年代没有对象。GC后堆中老年代新近了8576K=12927K-4351K, 对象计算出老年代使用率 9.81%= 8576K/(126720K-39296K),耗时 0.0155448 secs

-  [Times: user=0.02 sys=0.00, real=0.01 secs] ：此次GC事件的持续时间，通过三个部分来衡量： user 部分表示所有 GC线程消耗的CPU时间； sys 部分表示系统调用和系统等待事件消耗的时间。 real 则表示应用程序暂停的时间。因为串行垃圾收集器(Serial Garbage Collector)只使用单个线程，所以这里 real = user + system ，0.01秒也就是10毫秒 。

  首次Full GC日志如下：

  2020-10-24T17:36:03.565+0800: 0.432: [GC (Allocation Failure) 2020-10-24T17:36:03.565+0800: 0.433: [DefNew: 39118K->4347K(39296K), 0.0058201 secs]2020-10-24T17:36:03.571+0800: 0.438: [Tenured: 92082K->92059K(92088K), 0.0135619 secs] 120842K->92625K(131384K), [Metaspace: 2820K->2820K(1056768K)], 0.0202701 secs] [Times: user=0.02 sys=0.00, real=0.02 secs] 

  分析2020-10-24T17:36:03.565+0800: 0.433时刻发生了Full GC 耗时0.02 secs，新生代39118K->4347K，回收后新生代利用率 11%=4347K/39296K。耗时0.00580secs。

   [Tenured: 92082K->92059K(92088K), 0.0135619 secs] 老年代的内存回收，老年代的新进了92082K对象,GC后老年代利用率99.9%=92059K/92088K，Metaspace: 2820K->2820K(1056768K)元空间占用了2820K。从发生的时间上观察，这次老年代的回收发生的时候刚好是在年轻代结束后，立即发生的。

   **观察每次年轻代GC，可以看出随着回收的内存的增大，GC的时间也基本线性增长。发生Full GC时，首先清理年轻代，在清理老年代。**

**2 UseParallelGC**

GC日志文件  [Paralle_512m.demo.log](Paralle_512m.demo.log) ，[Paralle_1g.demo.log](Paralle_1g.demo.log) ，[Paralle_2g.demo.log](Paralle_2g.demo.log) 

首次GC  [Paralle_512m.demo.log](Paralle_512m.demo.log)

2020-10-24T18:22:45.898+0800: 0.210: [GC (Allocation Failure) [PSYoungGen: 131584K->21495K(153088K)] 131584K->39818K(502784K), 0.0137571 secs] [Times: user=0.03 sys=0.03, real=0.01 secs] 

- 分析：PSYoungGen  JVM在启动后0.210s时刻发生首次GC，GC耗时0.0137571，回收垃圾110089K=131584K-21495K。提升老年代对象18323K=39818K-21495K。系统停顿0.013s

Full GC

2020-10-24T18:22:46.233+0800: 0.545: [Full GC (Ergonomics) [PSYoungGen: 21131K->0K(116736K)] [ParOldGen: 315738K->235616K(349696K)] 336870K->235616K(466432K), [Metaspace: 2820K->2820K(1056768K)], 0.0503044 secs] [Times: user=0.17 sys=0.00, real=0.05 secs] 

- Full GC 原因：Ergonomics；日志中上一次Minor 如下 ：GC 2020-10-24T18:22:46.218+0800: 0.529: [GC (Allocation Failure) [PSYoungGen: 96442K->21131K(116736K)] 374849K->336870K(466432K), 0.0157317 secs] [Times: user=0.05 sys=0.00, real=0.02 secs] ，提升至老年代对象占用315739K=336870K-21131K。老年占用率 90.28%=315739K/349696K;剩余空间33957K=349696K-315739K 从前面11次Minor  GC 大致计算出 每次Minor GC 提升至老年代的对象大小为29741.6K,虚拟机自适应调节策略认为 **晋升到老生代的平均大小大于老生代的剩余大小** （平均值加上偏差和权重计算得出的平均计算大小），触发GC
- [PSYoungGen: 21131K->0K(116736K)]  YongGen区 全部回收
- [ParOldGen: 315738K->235616K(349696K)] 老年代回收 18323K=315738K-235616K
-  [Metaspace: 2820K->2820K(1056768K)], 0.0503044 secs] 元空间没有发生垃圾收集，Full GC停顿时间0.0503044 s。整个Full GC时间比较长

**3 +UseConcMarkSweepGC**

GC日志  [CMSGC_512m.demo.log](CMSGC_512m.demo.log) ， [CMSGC_1g.demo.log](CMSGC_1g.demo.log) ， [CMSGC_2g.demo.log](CMSGC_2g.demo.log) 

 [CMSGC_512m.demo.log](CMSGC_512m.demo.log) 首次

[GC (Allocation Failure) 2020-10-25T21:41:39.844+0800: 0.263: [ParNew: 272638K->34048K(306688K), 0.0196342 secs] 272638K->87834K(1014528K), 0.0198509 secs] [Times: user=0.02 sys=0.05, real=0.02 secs] 

- 分析：新生代采用ParNewGC，时SerialGC的多线程版本;回收了238590K 耗时0.0198509 secs,回收速率12019102K/19.8ms = 11.7M/ms,回收速率要大于SerialGC。


CMS Full GC日志

020-10-25T21:41:40.171+0800: 0.591: [GC (CMS Initial Mark) [1 CMS-initial-mark: 374672K(707840K)] 408880K(1014528K), 0.0001300 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
2020-10-25T21:41:40.172+0800: 0.591: [CMS-concurrent-mark-start]
2020-10-25T21:41:40.180+0800: 0.599: [CMS-concurrent-mark: 0.008/0.008 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
2020-10-25T21:41:40.180+0800: 0.599: [CMS-concurrent-preclean-start]
2020-10-25T21:41:40.181+0800: 0.600: [CMS-concurrent-preclean: 0.001/0.001 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
2020-10-25T21:41:40.181+0800: 0.600: [CMS-concurrent-abortable-preclean-start]

- 分析：CMS GC分为
  - ​	GC (CMS Initial Mark：初始标记 ，速度很快

总结：Parallel GC 的 年轻代收集的性能比SerialGC要快，原因时ParallelGC 年轻带采用多线程并行收集。

UseConcMarkSweepGC：年轻代使用ParNewGC,ParNewGC时并行的GC，除了并行特性，其他的特性与SerialGC相同。









