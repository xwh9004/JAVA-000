学习笔记

GC日志分析

**1 SerialGC** 

日志文件， [SerialGC_512m.demo.log](SerialGC_512m.demo.log)， [SerialGC_1g.demo.log](SerialGC_1g.demo.log) ，[SerialGC_2g.demo.log](SerialGC_2g.demo.log) 

SerialGC_512m.demo.log中第一次发生GC日志如下：

2020-10-24T17:36:03.460+0800: 0.327: [GC (Allocation Failure) 2020-10-24T17:36:03.461+0800: 0.327: [DefNew: 34847K->4351K(39296K), 0.0082927 secs] 34847K->12927K(126720K), 0.0084992 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] 

- Allocation Failure：触发GC原因

- 2020-10-24T17:36:03.461+0800: 0.327：触发GC时刻，JVM启动后0.328s发生一次GC

- DefNew：GC垃圾收集器名称，DefNew表示 年轻代使用的单线程、标记­复制、STW 垃圾收集器 

-  34847K->4351K(39296K)： 34847K 表示GC前新生代使用大小，4351K表示 GC后新生代使用，括号中39296K新生   代总大小，可计算出GC回收了 30496K=34847K-4351K,可以看到GC前新生代使用率 88.6%=34847K/39296K，GC后新生代使用率 11%=4351K/39296K。0.0082927 secs 表示 GC执行的时间

-   34847K->12927K(126720K), 0.0084992 secs：34847K，表示GC前Java堆总的使用大小，12927K，表示GC后Java堆总的使用大小，126720K,表示Java堆的总大小，可以看到首次GC前，tenured老年代没有对象。GC后堆中老年代新近了8576K=12927K-4351K, 对象计算出老年代使用率 9.81%= 8576K/(126720K-39296K),耗时 0.0155448 secs

-  [Times: user=0.02 sys=0.00, real=0.01 secs] ：此次GC事件的持续时间，通过三个部分来衡量： user 部分表示所有 GC线程消耗的CPU时间； sys 部分表示系统调用和系统等待事件消耗的时间。 real 则表示应用程序暂停的时间。因为串行垃圾收集器(Serial Garbage Collector)只使用单个线程，所以这里 real = user + system ，0.01秒也就是10毫秒 。

  首次Full GC日志如下：

  2020-10-24T17:36:03.565+0800: 0.432: [GC (Allocation Failure) 2020-10-24T17:36:03.565+0800: 0.433: [DefNew: 39118K->4347K(39296K), 0.0058201 secs]2020-10-24T17:36:03.571+0800: 0.438: [Tenured: 92082K->92059K(92088K), 0.0135619 secs] 120842K->92625K(131384K), [Metaspace: 2820K->2820K(1056768K)], 0.0202701 secs] [Times: user=0.02 sys=0.00, real=0.02 secs] 

  分析2020-10-24T17:36:03.565+0800: 0.433时刻发生了Full GC 耗时0.02 secs，新生代39118K->4347K，回收后新生代利用率 11%=4347K/39296K。耗时0.00580secs。

   [Tenured: 92082K->92059K(92088K), 0.0135619 secs] 老年代的内存回收，老年代的新进了92082K对象,GC后老年代利用率99.9%=92059K/92088K，Metaspace: 2820K->2820K(1056768K)元空间占用了2820K。从发生的时间上观察，这次老年代的回收发生的时候刚好是在年轻代结束后，立即发生的。

   **观察每次年轻代GC，可以看出随着回收的内存的增大，GC的时间也基本线性增长。发生Full GC时，首先清理年轻代，在清理老年代。**
