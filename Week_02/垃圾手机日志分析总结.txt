
+UseSerialGC 收集器
	.Yong区采用DefNew收集器，这是一款单线程、标记­复制、STW 垃圾收集器 .Old区采用Tenured 表明使用的是单线程的STW垃圾收集器，
	使用的算法为 标记‐清除‐整理(mark‐sweep‐compact ) 。
	观察每次年轻代GC，可以看出随着回收的内存的增大，GC的时间也基本线性增长。发生Full观察每次年轻代GC，可以看出随着回收的内存的增大，GC的时间也基本线性增长。
	发生Full GC时，首先清理年轻代，再清理老年代。整个过程是单线程的
+UseParallelGC
    Yong区采用 PSYoungGen – 垃圾收集器的名称。这个名字表示的是在年轻代中使用的：并行的 标记‐复制(mark‐copy) ，全线暂停(STW) 垃圾收集器
	Old区采用 ParOldGen 的垃圾收集器，这是一款并行 STW垃圾收集器，算法为 标记‐清除‐整理(mark‐sweep‐compact) 
    从运行程序的吞吐量来说，UseParallelGC是要优于UseSerialGC。
+UseConcMarkSweepGC
     年轻代开始使用 ParNew ParNew收集器实质上是Serial收集器的多线程并行版本	
	 老年代使用率达到一定阈值开始对整个堆CMS垃圾回收
	 主要分为初始标记，并发标记，重新标记，并发清除，只有初始标记，和重新标记需要STW,但是整体STW的时间都非常短。
     在并发标记阶段持续的时间很长，在该阶段与垃圾收集线程和用户线程并行，会产生新的无法标记的垃圾，最后重新标记修正新产生的垃圾。
	 最后执行并发清除。因为采用的标记-清除算法，所以，容易产生碎片垃圾。进而触发新的Full GC,要是CMS运行期间预留的内存无法满足程序分配新对象的需要，
	 就会出现一次“并发失败”（Concurrent Mode Failure） ， 这时候虚拟机将不得不启动后备预案： 冻结用户线程的执行， 
	 临时启用Serial Old收集器来重新进行老年代的垃圾收集，但这样停顿时间就很长了。在日志CMSGC_1g.demo.log)出现Concurrent Mode Failure STW时间70ms。
+UserG1GC	 
     G1日志非常复制细化。在应用刚启动的时候G1的 的垃圾回收只发生在yong区，即G1收集器会在Fully Young模式下运行，该过程涉及Survivor区转移。会出现短暂的STW。
	 在Old regions区的垃圾回收采用的并发标记清理算法，基本流程与CMS很相似。在Old regions区收集过后，Old regions的region很多时候并不能全部释放，这是JVM会
	 启动混合过程，这个过程不仅会灰机Yong regions也会收集Old regions。从日志中可以看出并发标记模式后有很多 mixed日志
	 （并不是马上发生在并发标记清理模式下）。
详细垃圾收集日志参考 垃圾收集器日志分析.md 文件	 
总结：	 
	...Minor GC 仅仅对 Yong区回收;
	...ull GC 清理了不仅清理了年轻代对象（一般全部清理）和老年代对象（90%降到67%），还清理Metaspace空间（例子中，元空间使用GC前都不变），所以Full GC的耗时远大与Minor GC;
	...从完整的GC日志来看，
	...Full GC与前一次的Minor GC都是紧挨着发生的，说明JVM在发生Minor GC后，JVM剩余内存仍小于平均晋升到老年代的内存大小，就触发Full GC（Full GC的一种自使用策略）。
	...采用标记-清除算法的垃圾回收器会产生较多的垃圾碎片，会过早的触发新的GC
	...ParallelGC 采用并行运行多个垃圾线程性能优于单线程的垃圾收集器。从日志对比中看出，SerialGC STW时间在50ms,ParallelGC STW=30ms,在随着并行垃圾线程数很大（远大于系统内核数）
	   STW的时间显著增多，大多数时间浪费在线程的调度和线程的上线文切换上（从压测数据上可以的到验证）
	...结合不同垃圾收集器的性能压测，可以看出在内存比较小的时候（<1g），系统性能差不多，
       当内存>1g的时候整个系统的吞吐量得到提升 （各GC性能对比有待进一步验证，Window系统 4核8g环境,压测效果不明显。。。） 